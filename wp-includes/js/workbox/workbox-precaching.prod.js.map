{"version":3,"names":[],"mappings":"","sources":["packages/workbox-precaching/index.mjs"],"sourcesContent":["this.workbox=this.workbox||{},this.workbox.precaching=function(t,e,n,s,c){\"use strict\";try{self[\"workbox:precaching:4.0.0-beta.2\"]&&_()}catch(t){}const o=[],i={get:()=>o,add(t){o.push(...t)}};const a=\"__WB_REVISION__\";function r(t){if(!t)throw new e.WorkboxError(\"add-to-cache-list-unexpected-type\",{entry:t});if(\"string\"==typeof t){const e=new URL(t,location);return{cacheKey:e.href,url:e.href}}const{revision:n,url:s}=t;if(!s)throw new e.WorkboxError(\"add-to-cache-list-unexpected-type\",{entry:t});if(!n){const t=new URL(s,location);return{cacheKey:t.href,url:t.href}}const c=new URL(s,location),o=new URL(s,location);return o.searchParams.set(a,n),{cacheKey:o.href,url:c.href}}class l{constructor(t){this.t=n.cacheNames.getPrecacheName(t),this.e=new Map}addToCacheList(t){for(const n of t){const{cacheKey:t,url:s}=r(n);if(this.e.has(s)&&this.e.get(s)!==t)throw new e.WorkboxError(\"add-to-cache-list-conflicting-entries\",{firstEntry:this.e.get(s),secondEntry:t});this.e.set(s,t)}}async install({event:t,plugins:e}={}){const n=[],s=[],c=await caches.open(this.t),o=await c.keys(),i=new Set(o.map(t=>t.url));for(const t of this.e.values())i.has(t)?s.push(t):n.push(t);const a=n.map(n=>this.n({event:t,plugins:e,url:n}));return await Promise.all(a),{updatedURLs:n,notUpdatedURLs:s}}async activate(){const t=await caches.open(this.t),e=await t.keys(),n=new Set(this.e.values()),s=[];for(const c of e)n.has(c.url)||(await t.delete(c),s.push(c.url));return{deletedURLs:s}}async n({url:t,event:n,plugins:o}){const i=new Request(t,{credentials:\"same-origin\"});let a,r=await c.fetchWrapper.fetch({event:n,plugins:o,request:i});for(const t of o||[])\"cacheWillUpdate\"in t&&(a=t.cacheWillUpdate);if(!(a?a({response:r}):r.status<400))throw new e.WorkboxError(\"bad-precaching-response\",{url:t,status:r.status});r.redirected&&(r=await async function(t){const e=t.clone(),n=\"body\"in e?Promise.resolve(e.body):e.blob(),s=await n;return new Response(s,{headers:e.headers,status:e.status,statusText:e.statusText})}(r)),await s.cacheWrapper.put({event:n,plugins:o,request:i,response:r,cacheName:this.t})}getURLsToCacheKeys(){return this.e}getCachedURLs(){return[...this.e.keys()]}getCacheKeyForURL(t){const e=new URL(t,location);return this.e.get(e.href)}}let u;const h=()=>(u||(u=new l),u);const d=(t,e)=>{const n=h().getURLsToCacheKeys();for(const s of function*(t,{ignoreURLParametersMatching:e,directoryIndex:n,cleanURLs:s,urlManipulation:c}={}){const o=new URL(t,location);o.hash=\"\",yield o.href;const i=function(t,e){for(const n of[...t.searchParams.keys()])e.some(t=>t.test(n))&&t.searchParams.delete(n);return t}(o,e);if(yield i.href,n&&i.pathname.endsWith(\"/\")){const t=new URL(i);t.pathname+=n,yield t.href}if(s){const t=new URL(i);t.pathname+=\".html\",yield t.href}if(c){const t=c({url:o});for(const e of t)yield e.href}}(t,e)){const t=n.get(s);if(t)return t}};let f=!1;const w=({ignoreURLParametersMatching:t=[/^utm_/],directoryIndex:e=\"index.html\",cleanURLs:s=!0,urlManipulation:c=null}={})=>{if(!f){const o=n.cacheNames.getPrecacheName();addEventListener(\"fetch\",n=>{const i=d(n.request.url,{cleanURLs:s,directoryIndex:e,ignoreURLParametersMatching:t,urlManipulation:c});if(!i)return;let a=caches.open(o).then(t=>t.match(i)).then(t=>t||fetch(i));n.respondWith(a)}),f=!0}};let y=!1;const p=t=>{const e=h();if(e.addToCacheList(t),!y&&t.length>0){const t=i.get();self.addEventListener(\"install\",n=>{n.waitUntil(e.install({event:n,plugins:t}).catch(t=>{throw t}))}),self.addEventListener(\"activate\",n=>{n.waitUntil(e.activate({event:n,plugins:t}))}),y=!0}};return t.addPlugins=(t=>{i.add(t)}),t.addRoute=w,t.cleanupOutdatedCaches=(()=>{addEventListener(\"activate\",t=>{const e=n.cacheNames.getPrecacheName();t.waitUntil((async(t,e=\"-precache-\")=>{const n=(await caches.keys()).filter(n=>n.includes(e)&&n.includes(self.registration.scope)&&n!==t);return await Promise.all(n.map(t=>caches.delete(t))),n})(e).then(t=>{}))})}),t.getCacheKeyForURL=(t=>{return h().getCacheKeyForURL(t)}),t.precache=p,t.precacheAndRoute=((t,e)=>{p(t),w(e)}),t.PrecacheController=l,t}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);\n"],"file":"workbox-precaching.prod.js"}