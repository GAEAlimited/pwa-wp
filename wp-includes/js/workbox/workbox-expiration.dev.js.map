{"version":3,"names":[],"mappings":"","sources":["packages/workbox-expiration/index.mjs"],"sourcesContent":["this.workbox = this.workbox || {};\nthis.workbox.expiration = (function (exports,DBWrapper_mjs,deleteDatabase_mjs,WorkboxError_mjs,assert_mjs,logger_mjs,cacheNames_mjs,getFriendlyURL_mjs,registerQuotaErrorCallback_mjs) {\n  'use strict';\n\n  try {\n    self['workbox:expiration:4.0.0-rc.0'] && _();\n  } catch (e) {} // eslint-disable-line\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  const DB_NAME = 'workbox-expiration';\n  const OBJECT_STORE_NAME = 'cache-entries';\n\n  const normalizeURL = unNormalizedUrl => {\n    const url = new URL(unNormalizedUrl, location);\n    url.hash = '';\n    return url.href;\n  };\n  /**\n   * Returns the timestamp model.\n   *\n   * @private\n   */\n\n\n  class CacheTimestampsModel {\n    /**\n     *\n     * @param {string} cacheName\n     *\n     * @private\n     */\n    constructor(cacheName) {\n      this._cacheName = cacheName;\n      this._db = new DBWrapper_mjs.DBWrapper(DB_NAME, 1, {\n        onupgradeneeded: event => this._handleUpgrade(event)\n      });\n    }\n    /**\n     * Should perform an upgrade of indexedDB.\n     *\n     * @param {Event} event\n     *\n     * @private\n     */\n\n\n    _handleUpgrade(event) {\n      const db = event.target.result; // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n      // have to use the `id` keyPath here and create our own values (a\n      // concatenation of `url + cacheName`) instead of simply using\n      // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\n\n      const objStore = db.createObjectStore(OBJECT_STORE_NAME, {\n        keyPath: 'id'\n      }); // TODO(philipwalton): once we don't have to support EdgeHTML, we can\n      // create a single index with the keyPath `['cacheName', 'timestamp']`\n      // instead of doing both these indexes.\n\n      objStore.createIndex('cacheName', 'cacheName', {\n        unique: false\n      });\n      objStore.createIndex('timestamp', 'timestamp', {\n        unique: false\n      }); // Previous versions of `workbox-expiration` used `this._cacheName`\n      // as the IDBDatabase name.\n\n      deleteDatabase_mjs.deleteDatabase(this._cacheName);\n    }\n    /**\n     * @param {string} url\n     * @param {number} timestamp\n     *\n     * @private\n     */\n\n\n    async setTimestamp(url, timestamp) {\n      url = normalizeURL(url);\n      await this._db.put(OBJECT_STORE_NAME, {\n        url,\n        timestamp,\n        cacheName: this._cacheName,\n        // Creating an ID from the URL and cache name won't be necessary once\n        // Edge switches to Chromium and all browsers we support work with\n        // array keyPaths.\n        id: this._getId(url)\n      });\n    }\n    /**\n     * Returns the timestamp stored for a given URL.\n     *\n     * @param {string} url\n     * @return {number}\n     *\n     * @private\n     */\n\n\n    async getTimestamp(url) {\n      const entry = await this._db.get(OBJECT_STORE_NAME, this._getId(url));\n      return entry.timestamp;\n    }\n    /**\n     * Iterates through all the entries in the object store (from newest to\n     * oldest) and removes entries once either `maxCount` is reached or the\n     * entry's timestamp is less than `minTimestamp`.\n     *\n     * @param {number} minTimestamp\n     * @param {number} maxCount\n     *\n     * @private\n     */\n\n\n    async expireEntries(minTimestamp, maxCount) {\n      return await this._db.transaction(OBJECT_STORE_NAME, 'readwrite', (txn, done) => {\n        const store = txn.objectStore(OBJECT_STORE_NAME);\n        const entriesDeleted = [];\n        let entriesNotDeletedCount = 0;\n\n        store.index('timestamp').openCursor(null, 'prev').onsuccess = ({\n          target\n        }) => {\n          const cursor = target.result;\n\n          if (cursor) {\n            const result = cursor.value; // TODO(philipwalton): once we can use a multi-key index, we\n            // won't have to check `cacheName` here.\n\n            if (result.cacheName === this._cacheName) {\n              // Delete an entry if it's older than the max age or\n              // if we already have the max number allowed.\n              if (minTimestamp && result.timestamp < minTimestamp || maxCount && entriesNotDeletedCount >= maxCount) {\n                cursor.delete(); // We only need to return the URL, not the whole entry.\n\n                entriesDeleted.push(cursor.value.url);\n              } else {\n                entriesNotDeletedCount++;\n              }\n            }\n\n            cursor.continue();\n          } else {\n            done(entriesDeleted);\n          }\n        };\n      });\n    }\n    /**\n     * Takes a URL and returns an ID that will be unique in the object store.\n     *\n     * @param {string} url\n     * @return {string}\n     */\n\n\n    _getId(url) {\n      // Creating an ID from the URL and cache name won't be necessary once\n      // Edge switches to Chromium and all browsers we support work with\n      // array keyPaths.\n      return this._cacheName + '|' + normalizeURL(url);\n    }\n\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * The `CacheExpiration` class allows you define an expiration and / or\n   * limit on the number of responses stored in a\n   * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n   *\n   * @memberof workbox.expiration\n   */\n\n  class CacheExpiration {\n    /**\n     * To construct a new CacheExpiration instance you must provide at least\n     * one of the `config` properties.\n     *\n     * @param {string} cacheName Name of the cache to apply restrictions to.\n     * @param {Object} config\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\n     * Entries used the least will be removed as the maximum is reached.\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n     * it's treated as stale and removed.\n     */\n    constructor(cacheName, config = {}) {\n      {\n        assert_mjs.assert.isType(cacheName, 'string', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'cacheName'\n        });\n\n        if (!(config.maxEntries || config.maxAgeSeconds)) {\n          throw new WorkboxError_mjs.WorkboxError('max-entries-or-age-required', {\n            moduleName: 'workbox-expiration',\n            className: 'CacheExpiration',\n            funcName: 'constructor'\n          });\n        }\n\n        if (config.maxEntries) {\n          assert_mjs.assert.isType(config.maxEntries, 'number', {\n            moduleName: 'workbox-expiration',\n            className: 'CacheExpiration',\n            funcName: 'constructor',\n            paramName: 'config.maxEntries'\n          }); // TODO: Assert is positive\n        }\n\n        if (config.maxAgeSeconds) {\n          assert_mjs.assert.isType(config.maxAgeSeconds, 'number', {\n            moduleName: 'workbox-expiration',\n            className: 'CacheExpiration',\n            funcName: 'constructor',\n            paramName: 'config.maxAgeSeconds'\n          }); // TODO: Assert is positive\n        }\n      }\n\n      this._isRunning = false;\n      this._rerunRequested = false;\n      this._maxEntries = config.maxEntries;\n      this._maxAgeSeconds = config.maxAgeSeconds;\n      this._cacheName = cacheName;\n      this._timestampModel = new CacheTimestampsModel(cacheName);\n    }\n    /**\n     * Expires entries for the given cache and given criteria.\n     */\n\n\n    async expireEntries() {\n      if (this._isRunning) {\n        this._rerunRequested = true;\n        return;\n      }\n\n      this._isRunning = true;\n      const minTimestamp = this._maxAgeSeconds ? Date.now() - this._maxAgeSeconds * 1000 : undefined;\n      const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries); // Delete URLs from the cache\n\n      const cache = await caches.open(this._cacheName);\n\n      for (const url of urlsExpired) {\n        await cache.delete(url);\n      }\n\n      {\n        if (urlsExpired.length > 0) {\n          logger_mjs.logger.groupCollapsed(`Expired ${urlsExpired.length} ` + `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` + `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` + `'${this._cacheName}' cache.`);\n          logger_mjs.logger.log(`Expired the following ${urlsExpired.length === 1 ? 'URL' : 'URLs'}:`);\n          urlsExpired.forEach(url => logger_mjs.logger.log(`    ${url}`));\n          logger_mjs.logger.groupEnd();\n        } else {\n          logger_mjs.logger.debug(`Cache expiration ran and found no entries to remove.`);\n        }\n      }\n\n      this._isRunning = false;\n\n      if (this._rerunRequested) {\n        this._rerunRequested = false;\n        this.expireEntries();\n      }\n    }\n    /**\n     * Update the timestamp for the given URL. This ensures the when\n     * removing entries based on maximum entries, most recently used\n     * is accurate or when expiring, the timestamp is up-to-date.\n     *\n     * @param {string} url\n     */\n\n\n    async updateTimestamp(url) {\n      {\n        assert_mjs.assert.isType(url, 'string', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'updateTimestamp',\n          paramName: 'url'\n        });\n      }\n\n      await this._timestampModel.setTimestamp(url, Date.now());\n    }\n    /**\n     * Can be used to check if a URL has expired or not before it's used.\n     *\n     * This requires a look up from IndexedDB, so can be slow.\n     *\n     * Note: This method will not remove the cached entry, call\n     * `expireEntries()` to remove indexedDB and Cache entries.\n     *\n     * @param {string} url\n     * @return {boolean}\n     */\n\n\n    async isURLExpired(url) {\n      {\n        if (!this._maxAgeSeconds) {\n          throw new WorkboxError_mjs.WorkboxError(`expired-test-without-max-age`, {\n            methodName: 'isURLExpired',\n            paramName: 'maxAgeSeconds'\n          });\n        }\n      }\n\n      const timestamp = await this._timestampModel.getTimestamp(url);\n      const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n      return timestamp < expireOlderThan;\n    }\n    /**\n     * Removes the IndexedDB object store used to keep track of cache expiration\n     * metadata.\n     */\n\n\n    async delete() {\n      // Make sure we don't attempt another rerun if we're called in the middle of\n      // a cache expiration.\n      this._rerunRequested = false;\n      await this._timestampModel.expireEntries(Infinity); // Expires all.\n    }\n\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * This plugin can be used in the Workbox APIs to regularly enforce a\n   * limit on the age and / or the number of cached requests.\n   *\n   * Whenever a cached request is used or updated, this plugin will look\n   * at the used Cache and remove any old or extra requests.\n   *\n   * When using `maxAgeSeconds`, requests may be used *once* after expiring\n   * because the expiration clean up will not have occurred until *after* the\n   * cached request has been used. If the request has a \"Date\" header, then\n   * a light weight expiration check is performed and the request will not be\n   * used immediately.\n   *\n   * When using `maxEntries`, the last request to be used will be the request\n   * that is removed from the Cache.\n   *\n   * @memberof workbox.expiration\n   */\n\n  class Plugin {\n    /**\n     * @param {Object} config\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\n     * Entries used the least will be removed as the maximum is reached.\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n     * it's treated as stale and removed.\n     * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n     * automatic deletion if the available storage quota has been exceeded.\n     */\n    constructor(config = {}) {\n      {\n        if (!(config.maxEntries || config.maxAgeSeconds)) {\n          throw new WorkboxError_mjs.WorkboxError('max-entries-or-age-required', {\n            moduleName: 'workbox-expiration',\n            className: 'Plugin',\n            funcName: 'constructor'\n          });\n        }\n\n        if (config.maxEntries) {\n          assert_mjs.assert.isType(config.maxEntries, 'number', {\n            moduleName: 'workbox-expiration',\n            className: 'Plugin',\n            funcName: 'constructor',\n            paramName: 'config.maxEntries'\n          });\n        }\n\n        if (config.maxAgeSeconds) {\n          assert_mjs.assert.isType(config.maxAgeSeconds, 'number', {\n            moduleName: 'workbox-expiration',\n            className: 'Plugin',\n            funcName: 'constructor',\n            paramName: 'config.maxAgeSeconds'\n          });\n        }\n      }\n\n      this._config = config;\n      this._maxAgeSeconds = config.maxAgeSeconds;\n      this._cacheExpirations = new Map();\n\n      if (config.purgeOnQuotaError) {\n        registerQuotaErrorCallback_mjs.registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n      }\n    }\n    /**\n     * A simple helper method to return a CacheExpiration instance for a given\n     * cache name.\n     *\n     * @param {string} cacheName\n     * @return {CacheExpiration}\n     *\n     * @private\n     */\n\n\n    _getCacheExpiration(cacheName) {\n      if (cacheName === cacheNames_mjs.cacheNames.getRuntimeName()) {\n        throw new WorkboxError_mjs.WorkboxError('expire-custom-caches-only');\n      }\n\n      let cacheExpiration = this._cacheExpirations.get(cacheName);\n\n      if (!cacheExpiration) {\n        cacheExpiration = new CacheExpiration(cacheName, this._config);\n\n        this._cacheExpirations.set(cacheName, cacheExpiration);\n      }\n\n      return cacheExpiration;\n    }\n    /**\n     * A \"lifecycle\" callback that will be triggered automatically by the\n     * `workbox.strategies` handlers when a `Response` is about to be returned\n     * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n     * the handler. It allows the `Response` to be inspected for freshness and\n     * prevents it from being used if the `Response`'s `Date` header value is\n     * older than the configured `maxAgeSeconds`.\n     *\n     * @param {Object} options\n     * @param {string} options.cacheName Name of the cache the response is in.\n     * @param {Response} options.cachedResponse The `Response` object that's been\n     *     read from a cache and whose freshness should be checked.\n     * @return {Response} Either the `cachedResponse`, if it's\n     *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n     *\n     * @private\n     */\n\n\n    cachedResponseWillBeUsed({\n      event,\n      request,\n      cacheName,\n      cachedResponse\n    }) {\n      if (!cachedResponse) {\n        return null;\n      }\n\n      let isFresh = this._isResponseDateFresh(cachedResponse); // Expire entries to ensure that even if the expiration date has\n      // expired, it'll only be used once.\n\n\n      const cacheExpiration = this._getCacheExpiration(cacheName);\n\n      cacheExpiration.expireEntries(); // Update the metadata for the request URL to the current timestamp,\n      // but don't `await` it as we don't want to block the response.\n\n      const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n\n      if (event) {\n        try {\n          event.waitUntil(updateTimestampDone);\n        } catch (error) {\n          {\n            logger_mjs.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache entry for '${getFriendlyURL_mjs.getFriendlyURL(event.request.url)}'.`);\n          }\n        }\n      }\n\n      return isFresh ? cachedResponse : null;\n    }\n    /**\n     * @param {Response} cachedResponse\n     * @return {boolean}\n     *\n     * @private\n     */\n\n\n    _isResponseDateFresh(cachedResponse) {\n      if (!this._maxAgeSeconds) {\n        // We aren't expiring by age, so return true, it's fresh\n        return true;\n      } // Check if the 'date' header will suffice a quick expiration check.\n      // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n      // discussion.\n\n\n      const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n\n      if (dateHeaderTimestamp === null) {\n        // Unable to parse date, so assume it's fresh.\n        return true;\n      } // If we have a valid headerTime, then our response is fresh iff the\n      // headerTime plus maxAgeSeconds is greater than the current time.\n\n\n      const now = Date.now();\n      return dateHeaderTimestamp >= now - this._maxAgeSeconds * 1000;\n    }\n    /**\n     * This method will extract the data header and parse it into a useful\n     * value.\n     *\n     * @param {Response} cachedResponse\n     * @return {number}\n     *\n     * @private\n     */\n\n\n    _getDateHeaderTimestamp(cachedResponse) {\n      if (!cachedResponse.headers.has('date')) {\n        return null;\n      }\n\n      const dateHeader = cachedResponse.headers.get('date');\n      const parsedDate = new Date(dateHeader);\n      const headerTime = parsedDate.getTime(); // If the Date header was invalid for some reason, parsedDate.getTime()\n      // will return NaN.\n\n      if (isNaN(headerTime)) {\n        return null;\n      }\n\n      return headerTime;\n    }\n    /**\n     * A \"lifecycle\" callback that will be triggered automatically by the\n     * `workbox.strategies` handlers when an entry is added to a cache.\n     *\n     * @param {Object} options\n     * @param {string} options.cacheName Name of the cache that was updated.\n     * @param {string} options.request The Request for the cached entry.\n     *\n     * @private\n     */\n\n\n    async cacheDidUpdate({\n      cacheName,\n      request\n    }) {\n      {\n        assert_mjs.assert.isType(cacheName, 'string', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'cacheDidUpdate',\n          paramName: 'cacheName'\n        });\n        assert_mjs.assert.isInstance(request, Request, {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'cacheDidUpdate',\n          paramName: 'request'\n        });\n      }\n\n      const cacheExpiration = this._getCacheExpiration(cacheName);\n\n      await cacheExpiration.updateTimestamp(request.url);\n      await cacheExpiration.expireEntries();\n    }\n    /**\n     * This is a helper method that performs two operations:\n     *\n     * - Deletes *all* the underlying Cache instances associated with this plugin\n     * instance, by calling caches.delete() on your behalf.\n     * - Deletes the metadata from IndexedDB used to keep track of expiration\n     * details for each Cache instance.\n     *\n     * When using cache expiration, calling this method is preferable to calling\n     * `caches.delete()` directly, since this will ensure that the IndexedDB\n     * metadata is also cleanly removed and open IndexedDB instances are deleted.\n     *\n     * Note that if you're *not* using cache expiration for a given cache, calling\n     * `caches.delete()` and passing in the cache's name should be sufficient.\n     * There is no Workbox-specific method needed for cleanup in that case.\n     */\n\n\n    async deleteCacheAndMetadata() {\n      // Do this one at a time instead of all at once via `Promise.all()` to\n      // reduce the chance of inconsistency if a promise rejects.\n      for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n        await caches.delete(cacheName);\n        await cacheExpiration.delete();\n      } // Reset this._cacheExpirations to its initial state.\n\n\n      this._cacheExpirations = new Map();\n    }\n\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  exports.CacheExpiration = CacheExpiration;\n  exports.Plugin = Plugin;\n\n  return exports;\n\n}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core));\n"],"file":"workbox-expiration.dev.js"}