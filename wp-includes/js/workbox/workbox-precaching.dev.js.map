{"version":3,"names":[],"mappings":"","sources":["packages/workbox-precaching/index.mjs"],"sourcesContent":["this.workbox = this.workbox || {};\nthis.workbox.precaching = (function (exports,WorkboxError_mjs,logger_mjs,assert_mjs,cacheNames_mjs,cacheWrapper_mjs,fetchWrapper_mjs,getFriendlyURL_mjs) {\n  'use strict';\n\n  try {\n    self['workbox:precaching:4.0.0-rc.0'] && _();\n  } catch (e) {} // eslint-disable-line\n\n  /*\n    Copyright 2019 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  const plugins = [];\n  const precachePlugins = {\n    /*\n     * @return {Array}\n     * @private\n     */\n    get() {\n      return plugins;\n    },\n\n    /*\n     * @param {Array} newPlugins\n     * @private\n     */\n    add(newPlugins) {\n      plugins.push(...newPlugins);\n    }\n\n  };\n\n  /*\n    Copyright 2019 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * Adds plugins to precaching.\n   *\n   * @param {Array<Object>} newPlugins\n   *\n   * @alias workbox.precaching.addPlugins\n   */\n\n  const addPlugins = newPlugins => {\n    precachePlugins.add(newPlugins);\n  };\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * @param {Response} response\n   * @return {Response}\n   *\n   * @private\n   * @memberof module:workbox-precaching\n   */\n\n  async function cleanRedirect(response) {\n    const clonedResponse = response.clone(); // Not all browsers support the Response.body stream, so fall back\n    // to reading the entire body into memory as a blob.\n\n    const bodyPromise = 'body' in clonedResponse ? Promise.resolve(clonedResponse.body) : clonedResponse.blob();\n    const body = await bodyPromise; // new Response() is happy when passed either a stream or a Blob.\n\n    return new Response(body, {\n      headers: clonedResponse.headers,\n      status: clonedResponse.status,\n      statusText: clonedResponse.statusText\n    });\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  const REVISION_SEARCH_PARAM = '__WB_REVISION__';\n  /**\n   * Converts a manifest entry into a versioned URL suitable for precaching.\n   *\n   * @param {Object} entry\n   * @return {string} A URL with versioning info.\n   *\n   * @private\n   * @memberof module:workbox-precaching\n   */\n\n  function createCacheKey(entry) {\n    if (!entry) {\n      throw new WorkboxError_mjs.WorkboxError('add-to-cache-list-unexpected-type', {\n        entry\n      });\n    } // If a precache manifest entry is a string, it's assumed to be a versioned\n    // URL, like '/app.abcd1234.js'. Return as-is.\n\n\n    if (typeof entry === 'string') {\n      const urlObject = new URL(entry, location);\n      return {\n        cacheKey: urlObject.href,\n        url: urlObject.href\n      };\n    }\n\n    const {\n      revision,\n      url\n    } = entry;\n\n    if (!url) {\n      throw new WorkboxError_mjs.WorkboxError('add-to-cache-list-unexpected-type', {\n        entry\n      });\n    } // If there's just a URL and no revision, then it's also assumed to be a\n    // versioned URL.\n\n\n    if (!revision) {\n      const urlObject = new URL(url, location);\n      return {\n        cacheKey: urlObject.href,\n        url: urlObject.href\n      };\n    } // Otherwise, construct a properly versioned URL using the custom Workbox\n    // search parameter along with the revision info.\n\n\n    const originalURL = new URL(url, location);\n    const cacheKeyURL = new URL(url, location);\n    cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);\n    return {\n      cacheKey: cacheKeyURL.href,\n      url: originalURL.href\n    };\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  const logGroup = (groupTitle, deletedURLs) => {\n    logger_mjs.logger.groupCollapsed(groupTitle);\n\n    for (const url of deletedURLs) {\n      logger_mjs.logger.log(url);\n    }\n\n    logger_mjs.logger.groupEnd();\n  };\n  /**\n   * @param {Array<string>} deletedURLs\n   *\n   * @private\n   * @memberof module:workbox-precaching\n   */\n\n\n  function printCleanupDetails(deletedURLs) {\n    const deletionCount = deletedURLs.length;\n\n    if (deletionCount > 0) {\n      logger_mjs.logger.groupCollapsed(`During precaching cleanup, ` + `${deletionCount} cached ` + `request${deletionCount === 1 ? ' was' : 's were'} deleted.`);\n      logGroup('Deleted Cache Requests', deletedURLs);\n      logger_mjs.logger.groupEnd();\n    }\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * @param {string} groupTitle\n   * @param {Array<string>} urls\n   *\n   * @private\n   */\n\n  function _nestedGroup(groupTitle, urls) {\n    if (urls.length === 0) {\n      return;\n    }\n\n    logger_mjs.logger.groupCollapsed(groupTitle);\n\n    for (const url of urls) {\n      logger_mjs.logger.log(url);\n    }\n\n    logger_mjs.logger.groupEnd();\n  }\n  /**\n   * @param {Array<string>} urlsToPrecache\n   * @param {Array<string>} urlsAlreadyPrecached\n   *\n   * @private\n   * @memberof module:workbox-precaching\n   */\n\n\n  function printInstallDetails(urlsToPrecache, urlsAlreadyPrecached) {\n    const precachedCount = urlsToPrecache.length;\n    const alreadyPrecachedCount = urlsAlreadyPrecached.length;\n\n    if (precachedCount || alreadyPrecachedCount) {\n      let message = `Precaching ${precachedCount} file${precachedCount === 1 ? '' : 's'}.`;\n\n      if (alreadyPrecachedCount > 0) {\n        message += ` ${alreadyPrecachedCount} ` + `file${alreadyPrecachedCount === 1 ? ' is' : 's are'} already cached.`;\n      }\n\n      logger_mjs.logger.groupCollapsed(message);\n\n      _nestedGroup(`View newly precached URLs.`, urlsToPrecache);\n\n      _nestedGroup(`View previously precached URLs.`, urlsAlreadyPrecached);\n\n      logger_mjs.logger.groupEnd();\n    }\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * Performs efficient precaching of assets.\n   *\n   * @memberof module:workbox-precaching\n   */\n\n  class PrecacheController {\n    /**\n     * Create a new PrecacheController.\n     *\n     * @param {string} [cacheName] An optional name for the cache, to override\n     * the default precache name.\n     */\n    constructor(cacheName) {\n      this._cacheName = cacheNames_mjs.cacheNames.getPrecacheName(cacheName);\n      this._urlsToCacheKeys = new Map();\n    }\n    /**\n     * This method will add items to the precache list, removing duplicates\n     * and ensuring the information is valid.\n     *\n     * @param {\n     * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>\n     * } entries Array of entries to precache.\n     */\n\n\n    addToCacheList(entries) {\n      {\n        assert_mjs.assert.isArray(entries, {\n          moduleName: 'workbox-precaching',\n          className: 'PrecacheController',\n          funcName: 'addToCacheList',\n          paramName: 'entries'\n        });\n      }\n\n      for (const entry of entries) {\n        const {\n          cacheKey,\n          url\n        } = createCacheKey(entry);\n\n        if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {\n          throw new WorkboxError_mjs.WorkboxError('add-to-cache-list-conflicting-entries', {\n            firstEntry: this._urlsToCacheKeys.get(url),\n            secondEntry: cacheKey\n          });\n        }\n\n        this._urlsToCacheKeys.set(url, cacheKey);\n      }\n    }\n    /**\n     * Precaches new and updated assets. Call this method from the service worker\n     * install event.\n     *\n     * @param {Object} options\n     * @param {Event} [options.event] The install event (if needed).\n     * @param {Array<Object>} [options.plugins] Plugins to be used for fetching\n     * and caching during install.\n     * @return {Promise<workbox.precaching.InstallResult>}\n     */\n\n\n    async install({\n      event,\n      plugins\n    } = {}) {\n      {\n        if (plugins) {\n          assert_mjs.assert.isArray(plugins, {\n            moduleName: 'workbox-precaching',\n            className: 'PrecacheController',\n            funcName: 'install',\n            paramName: 'plugins'\n          });\n        }\n      }\n\n      const urlsToPrecache = [];\n      const urlsAlreadyPrecached = [];\n      const cache = await caches.open(this._cacheName);\n      const alreadyCachedRequests = await cache.keys();\n      const alreadyCachedURLs = new Set(alreadyCachedRequests.map(request => request.url));\n\n      for (const cacheKey of this._urlsToCacheKeys.values()) {\n        if (alreadyCachedURLs.has(cacheKey)) {\n          urlsAlreadyPrecached.push(cacheKey);\n        } else {\n          urlsToPrecache.push(cacheKey);\n        }\n      }\n\n      const precacheRequests = urlsToPrecache.map(url => {\n        return this._addURLToCache({\n          event,\n          plugins,\n          url\n        });\n      });\n      await Promise.all(precacheRequests);\n\n      {\n        printInstallDetails(urlsToPrecache, urlsAlreadyPrecached);\n      }\n\n      return {\n        updatedURLs: urlsToPrecache,\n        notUpdatedURLs: urlsAlreadyPrecached\n      };\n    }\n    /**\n     * Deletes assets that are no longer present in the current precache manifest.\n     * Call this method from the service worker activate event.\n     *\n     * @return {Promise<workbox.precaching.CleanupResult>}\n     */\n\n\n    async activate() {\n      const cache = await caches.open(this._cacheName);\n      const currentlyCachedRequests = await cache.keys();\n      const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n      const deletedURLs = [];\n\n      for (const request of currentlyCachedRequests) {\n        if (!expectedCacheKeys.has(request.url)) {\n          await cache.delete(request);\n          deletedURLs.push(request.url);\n        }\n      }\n\n      {\n        printCleanupDetails(deletedURLs);\n      }\n\n      return {\n        deletedURLs\n      };\n    }\n    /**\n     * Requests the entry and saves it to the cache if the response is valid.\n     * By default, any response with a status code of less than 400 (including\n     * opaque responses) is considered valid.\n     *\n     * If you need to use custom criteria to determine what's valid and what\n     * isn't, then pass in an item in `options.plugins` that implements the\n     * `cacheWillUpdate()` lifecycle event.\n     *\n     * @private\n     * @param {Object} options\n     * @param {string} options.url The URL to fetch and cache.\n     * @param {Event} [options.event] The install event (if passed).\n     * @param {Array<Object>} [options.plugins] An array of plugins to apply to\n     * fetch and caching.\n     */\n\n\n    async _addURLToCache({\n      url,\n      event,\n      plugins\n    }) {\n      const request = new Request(url, {\n        credentials: 'same-origin'\n      });\n      let response = await fetchWrapper_mjs.fetchWrapper.fetch({\n        event,\n        plugins,\n        request\n      }); // Allow developers to override the default logic about what is and isn't\n      // valid by passing in a plugin implementing cacheWillUpdate(), e.g.\n      // a workbox.cacheableResponse.Plugin instance.\n\n      let cacheWillUpdateCallback;\n\n      for (const plugin of plugins || []) {\n        if ('cacheWillUpdate' in plugin) {\n          cacheWillUpdateCallback = plugin.cacheWillUpdate;\n        }\n      }\n\n      const isValidResponse = cacheWillUpdateCallback ? // Use a callback if provided. It returns a truthy value if valid.\n      cacheWillUpdateCallback({\n        event,\n        request,\n        response\n      }) : // Otherwise, default to considering any response status under 400 valid.\n      // This includes, by default, considering opaque responses valid.\n      response.status < 400; // Consider this a failure, leading to the `install` handler failing, if\n      // we get back an invalid response.\n\n      if (!isValidResponse) {\n        throw new WorkboxError_mjs.WorkboxError('bad-precaching-response', {\n          url,\n          status: response.status\n        });\n      }\n\n      if (response.redirected) {\n        response = await cleanRedirect(response);\n      }\n\n      await cacheWrapper_mjs.cacheWrapper.put({\n        event,\n        plugins,\n        request,\n        response,\n        cacheName: this._cacheName\n      });\n    }\n    /**\n     * Returns a mapping of a precached URL to the corresponding cache key, taking\n     * into account the revision information for the URL.\n     *\n     * @return {Map<string, string>} A URL to cache key mapping.\n     */\n\n\n    getURLsToCacheKeys() {\n      return this._urlsToCacheKeys;\n    }\n    /**\n     * Returns a list of all the URLs that have been precached by the current\n     * service worker.\n     *\n     * @return {Array<string>} The precached URLs.\n     */\n\n\n    getCachedURLs() {\n      return [...this._urlsToCacheKeys.keys()];\n    }\n    /**\n     * Returns the cache key used for storing a given URL. If that URL is\n     * unversioned, like `/index.html', then the cache key will be the original\n     * URL with a search parameter appended to it.\n     *\n     * @param {string} url A URL whose cache key you want to look up.\n     * @return {string} The versioned URL that corresponds to a cache key\n     * for the original URL, or undefined if that URL isn't precached.\n     */\n\n\n    getCacheKeyForURL(url) {\n      const urlObject = new URL(url, location);\n      return this._urlsToCacheKeys.get(urlObject.href);\n    }\n\n  }\n\n  /*\n    Copyright 2019 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  let precacheController;\n  /**\n   * @return {PrecacheController}\n   * @private\n   */\n\n  const getOrCreatePrecacheController = () => {\n    if (!precacheController) {\n      precacheController = new PrecacheController();\n    }\n\n    return precacheController;\n  };\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * Removes any URL search parameters that should be ignored.\n   *\n   * @param {URL} urlObject The original URL.\n   * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against\n   * each search parameter name. Matches mean that the search parameter should be\n   * ignored.\n   * @return {URL} The URL with any ignored search parameters removed.\n   *\n   * @private\n   * @memberof module:workbox-precaching\n   */\n\n  function removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching) {\n    // Convert the iterable into an array at the start of the loop to make sure\n    // deletion doesn't mess up iteration.\n    for (const paramName of [...urlObject.searchParams.keys()]) {\n      if (ignoreURLParametersMatching.some(regExp => regExp.test(paramName))) {\n        urlObject.searchParams.delete(paramName);\n      }\n    }\n\n    return urlObject;\n  }\n\n  /*\n    Copyright 2019 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * Generator function that yields possible variations on the original URL to\n   * check, one at a time.\n   *\n   * @param {string} url\n   * @param {Object} options\n   *\n   * @private\n   * @memberof module:workbox-precaching\n   */\n\n  function* generateURLVariations(url, {\n    ignoreURLParametersMatching,\n    directoryIndex,\n    cleanURLs,\n    urlManipulation\n  } = {}) {\n    const urlObject = new URL(url, location);\n    urlObject.hash = '';\n    yield urlObject.href;\n    const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);\n    yield urlWithoutIgnoredParams.href;\n\n    if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {\n      const directoryURL = new URL(urlWithoutIgnoredParams);\n      directoryURL.pathname += directoryIndex;\n      yield directoryURL.href;\n    }\n\n    if (cleanURLs) {\n      const cleanURL = new URL(urlWithoutIgnoredParams);\n      cleanURL.pathname += '.html';\n      yield cleanURL.href;\n    }\n\n    if (urlManipulation) {\n      const additionalURLs = urlManipulation({\n        url: urlObject\n      });\n\n      for (const urlToAttempt of additionalURLs) {\n        yield urlToAttempt.href;\n      }\n    }\n  }\n\n  /*\n    Copyright 2019 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * This function will take the request URL and manipulate it based on the\n   * configuration options.\n   *\n   * @param {string} url\n   * @param {Object} options\n   * @return {string} Returns the URL in the cache that matches the request,\n   * if possible.\n   *\n   * @private\n   */\n\n  const getCacheKeyForURL = (url, options) => {\n    const precacheController = getOrCreatePrecacheController();\n    const urlsToCacheKeys = precacheController.getURLsToCacheKeys();\n\n    for (const possibleURL of generateURLVariations(url, options)) {\n      const possibleCacheKey = urlsToCacheKeys.get(possibleURL);\n\n      if (possibleCacheKey) {\n        return possibleCacheKey;\n      }\n    }\n  };\n\n  /*\n    Copyright 2019 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  let listenerAdded = false;\n  /**\n   * Add a `fetch` listener to the service worker that will\n   * respond to\n   * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n   * with precached assets.\n   *\n   * Requests for assets that aren't precached, the `FetchEvent` will not be\n   * responded to, allowing the event to fall through to other `fetch` event\n   * listeners.\n   *\n   * @param {Object} options\n   * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n   * check cache entries for a URLs ending with '/' to see if there is a hit when\n   * appending the `directoryIndex` value.\n   * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/]] An\n   * array of regex's to remove search params when looking for a cache match.\n   * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n   * check the cache for the URL with a `.html` added to the end of the end.\n   * @param {workbox.precaching~urlManipulation} [options.urlManipulation]\n   * This is a function that should take a URL and return an array of\n   * alternative URL's that should be checked for precache matches.\n   *\n   * @alias workbox.precaching.addRoute\n   */\n\n  const addRoute = ({\n    ignoreURLParametersMatching = [/^utm_/],\n    directoryIndex = 'index.html',\n    cleanURLs = true,\n    urlManipulation = null\n  } = {}) => {\n    if (!listenerAdded) {\n      const cacheName = cacheNames_mjs.cacheNames.getPrecacheName();\n      addEventListener('fetch', event => {\n        const precachedURL = getCacheKeyForURL(event.request.url, {\n          cleanURLs,\n          directoryIndex,\n          ignoreURLParametersMatching,\n          urlManipulation\n        });\n\n        if (!precachedURL) {\n          {\n            logger_mjs.logger.debug(`Precaching did not find a match for ` + getFriendlyURL_mjs.getFriendlyURL(event.request.url));\n          }\n\n          return;\n        }\n\n        let responsePromise = caches.open(cacheName).then(cache => {\n          return cache.match(precachedURL);\n        }).then(cachedResponse => {\n          if (cachedResponse) {\n            return cachedResponse;\n          } // Fall back to the network if we don't have a cached response\n          // (perhaps due to manual cache cleanup).\n\n\n          {\n            logger_mjs.logger.warn(`The precached response for ` + `${getFriendlyURL_mjs.getFriendlyURL(precachedURL)} in ${cacheName} was not found. ` + `Falling back to the network instead.`);\n          }\n\n          return fetch(precachedURL);\n        });\n\n        {\n          responsePromise = responsePromise.then(response => {\n            // Workbox is going to handle the route.\n            // print the routing details to the console.\n            logger_mjs.logger.groupCollapsed(`Precaching is responding to: ` + getFriendlyURL_mjs.getFriendlyURL(event.request.url));\n            logger_mjs.logger.log(`Serving the precached url: ${precachedURL}`);\n            logger_mjs.logger.groupCollapsed(`View request details here.`);\n            logger_mjs.logger.log(event.request);\n            logger_mjs.logger.groupEnd();\n            logger_mjs.logger.groupCollapsed(`View response details here.`);\n            logger_mjs.logger.log(response);\n            logger_mjs.logger.groupEnd();\n            logger_mjs.logger.groupEnd();\n            return response;\n          });\n        }\n\n        event.respondWith(responsePromise);\n      });\n      listenerAdded = true;\n    }\n  };\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  const SUBSTRING_TO_FIND = '-precache-';\n  /**\n   * Cleans up incompatible precaches that were created by older versions of\n   * Workbox, by a service worker registered under the current scope.\n   *\n   * This is meant to be called as part of the `activate` event.\n   *\n   * This should be safe to use as long as you don't include `substringToFind`\n   * (defaulting to `-precache-`) in your non-precache cache names.\n   *\n   * @param {string} currentPrecacheName The cache name currently in use for\n   * precaching. This cache won't be deleted.\n   * @param {string} [substringToFind='-precache-'] Cache names which include this\n   * substring will be deleted (excluding `currentPrecacheName`).\n   * @return {Array<string>} A list of all the cache names that were deleted.\n   *\n   * @private\n   * @memberof module:workbox-precaching\n   */\n\n  const deleteOutdatedCaches = async (currentPrecacheName, substringToFind = SUBSTRING_TO_FIND) => {\n    const cacheNames = await caches.keys();\n    const cacheNamesToDelete = cacheNames.filter(cacheName => {\n      return cacheName.includes(substringToFind) && cacheName.includes(self.registration.scope) && cacheName !== currentPrecacheName;\n    });\n    await Promise.all(cacheNamesToDelete.map(cacheName => caches.delete(cacheName)));\n    return cacheNamesToDelete;\n  };\n\n  /*\n    Copyright 2019 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * Adds an `activate` event listener which will clean up incompatible\n   * precaches that were created by older versions of Workbox.\n   *\n   * @alias workbox.precaching.cleanupOutdatedCaches\n   */\n\n  const cleanupOutdatedCaches = () => {\n    addEventListener('activate', event => {\n      const cacheName = cacheNames_mjs.cacheNames.getPrecacheName();\n      event.waitUntil(deleteOutdatedCaches(cacheName).then(cachesDeleted => {\n        {\n          if (cachesDeleted.length > 0) {\n            logger_mjs.logger.log(`The following out-of-date precaches were cleaned up ` + `automatically:`, cachesDeleted);\n          }\n        }\n      }));\n    });\n  };\n\n  /*\n    Copyright 2019 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * Takes in a URL, and returns the corresponding URL that could be used to\n   * lookup the entry in the precache.\n   *\n   * If a relative URL is provided, the location of the service worker file will\n   * be used as the base.\n   *\n   * For precached entries without revision information, the cache key will be the\n   * same as the original URL.\n   *\n   * For precached entries with revision information, the cache key will be the\n   * original URL with the addition of a query parameter used for keeping track of\n   * the revision info.\n   *\n   * @param {string} url The URL whose cache key to look up.\n   * @return {string} The cache key that corresponds to that URL.\n   *\n   * @alias workbox.precaching.getCacheKeyForURL\n   */\n\n  const getCacheKeyForURL$1 = url => {\n    const precacheController = getOrCreatePrecacheController();\n    return precacheController.getCacheKeyForURL(url);\n  };\n\n  /*\n    Copyright 2019 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  let listenersAdded = false;\n  /**\n   * Adds items to the precache list, removing any duplicates and\n   * stores the files in the\n   * [\"precache cache\"]{@link module:workbox-core.cacheNames} when the service\n   * worker installs.\n   *\n   * This method can be called multiple times.\n   *\n   * Please note: This method **will not** serve any of the cached files for you.\n   * It only precaches files. To respond to a network request you call\n   * [addRoute()]{@link module:workbox-precaching.addRoute}.\n   *\n   * If you have a single array of files to precache, you can just call\n   * [precacheAndRoute()]{@link module:workbox-precaching.precacheAndRoute}.\n   *\n   * @param {Array<Object|string>} entries Array of entries to precache.\n   *\n   * @alias workbox.precaching.precache\n   */\n\n  const precache = entries => {\n    const precacheController = getOrCreatePrecacheController();\n    precacheController.addToCacheList(entries);\n\n    if (!listenersAdded && entries.length > 0) {\n      const plugins = precachePlugins.get();\n      self.addEventListener('install', event => {\n        event.waitUntil(precacheController.install({\n          event,\n          plugins\n        }).catch(error => {\n          {\n            logger_mjs.logger.error(`Service worker installation failed. It will ` + `be retried automatically during the next navigation.`);\n          } // Re-throw the error to ensure installation fails.\n\n\n          throw error;\n        }));\n      });\n      self.addEventListener('activate', event => {\n        event.waitUntil(precacheController.activate({\n          event,\n          plugins\n        }));\n      });\n      listenersAdded = true;\n    }\n  };\n\n  /*\n    Copyright 2019 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * This method will add entries to the precache list and add a route to\n   * respond to fetch events.\n   *\n   * This is a convenience method that will call\n   * [precache()]{@link module:workbox-precaching.precache} and\n   * [addRoute()]{@link module:workbox-precaching.addRoute} in a single call.\n   *\n   * @param {Array<Object|string>} entries Array of entries to precache.\n   * @param {Object} options See\n   * [addRoute() options]{@link module:workbox-precaching.addRoute}.\n   *\n   * @alias workbox.precaching.precacheAndRoute\n   */\n\n  const precacheAndRoute = (entries, options) => {\n    precache(entries);\n    addRoute(options);\n  };\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  {\n    assert_mjs.assert.isSWEnv('workbox-precaching');\n  }\n\n  exports.addPlugins = addPlugins;\n  exports.addRoute = addRoute;\n  exports.cleanupOutdatedCaches = cleanupOutdatedCaches;\n  exports.getCacheKeyForURL = getCacheKeyForURL$1;\n  exports.precache = precache;\n  exports.precacheAndRoute = precacheAndRoute;\n  exports.PrecacheController = PrecacheController;\n\n  return exports;\n\n}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private));\n"],"file":"workbox-precaching.dev.js"}