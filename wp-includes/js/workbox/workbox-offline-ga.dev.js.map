{"version":3,"names":[],"mappings":"","sources":["packages/workbox-google-analytics/browser.mjs"],"sourcesContent":["this.workbox = this.workbox || {};\nthis.workbox.googleAnalytics = (function (exports,Plugin_mjs,cacheNames_mjs,Route_mjs,Router_mjs,NetworkFirst_mjs,NetworkOnly_mjs) {\n  'use strict';\n\n  try {\n    self.workbox.v['workbox:google-analytics:4.0.0-alpha.0'] = 1;\n  } catch (e) {} // eslint-disable-line\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  const QUEUE_NAME = 'workbox-google-analytics';\n  const MAX_RETENTION_TIME = 60 * 48; // Two days in minutes\n\n  const GOOGLE_ANALYTICS_HOST = 'www.google-analytics.com';\n  const GTM_HOST = 'www.googletagmanager.com';\n  const ANALYTICS_JS_PATH = '/analytics.js';\n  const GTAG_JS_PATH = '/gtag/js';\n  // endpoints. Most of the time the default path (/collect) is used, but\n  // occasionally an experimental endpoint is used when testing new features,\n  // (e.g. /r/collect or /j/collect)\n\n  const COLLECT_PATHS_REGEX = /^\\/(\\w+\\/)?collect/;\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * Promisifies the FileReader API to await a text response from a Blob.\n   *\n   * @param {Blob} blob\n   * @return {Promise<string>}\n   *\n   * @private\n   */\n\n  const getTextFromBlob = async blob => {\n    // This usage of `return await new Promise...` is intentional to work around\n    // a bug in the transpiled/minified output.\n    // See https://github.com/GoogleChrome/workbox/issues/1186\n    return await new Promise((resolve, reject) => {\n      const reader = new FileReader();\n\n      reader.onloadend = () => resolve(reader.result);\n\n      reader.onerror = () => reject(reader.error);\n\n      reader.readAsText(blob);\n    });\n  };\n  /**\n   * Creates the requestWillDequeue callback to be used with the background\n   * sync queue plugin. The callback takes the failed request and adds the\n   * `qt` param based on the current time, as well as applies any other\n   * user-defined hit modifications.\n   *\n   * @param {Object} config See workbox.googleAnalytics.initialize.\n   * @return {Function} The requestWillDequeu callback function.\n   *\n   * @private\n   */\n\n\n  const createRequestWillReplayCallback = config => {\n    return async storableRequest => {\n      let {\n        url,\n        requestInit,\n        timestamp\n      } = storableRequest;\n      url = new URL(url); // Measurement protocol requests can set their payload parameters in either\n      // the URL query string (for GET requests) or the POST body.\n\n      let params;\n\n      if (requestInit.body) {\n        const payload = requestInit.body instanceof Blob ? await getTextFromBlob(requestInit.body) : requestInit.body;\n        params = new URLSearchParams(payload);\n      } else {\n        params = url.searchParams;\n      } // Calculate the qt param, accounting for the fact that an existing\n      // qt param may be present and should be updated rather than replaced.\n\n\n      const originalHitTime = timestamp - (Number(params.get('qt')) || 0);\n      const queueTime = Date.now() - originalHitTime; // Set the qt param prior to applying the hitFilter or parameterOverrides.\n\n      params.set('qt', queueTime);\n\n      if (config.parameterOverrides) {\n        for (const param of Object.keys(config.parameterOverrides)) {\n          const value = config.parameterOverrides[param];\n          params.set(param, value);\n        }\n      }\n\n      if (typeof config.hitFilter === 'function') {\n        config.hitFilter.call(null, params);\n      }\n\n      requestInit.body = params.toString();\n      requestInit.method = 'POST';\n      requestInit.mode = 'cors';\n      requestInit.credentials = 'omit';\n      requestInit.headers = {\n        'Content-Type': 'text/plain'\n      }; // Ignore URL search params as they're now in the post body.\n\n      storableRequest.url = `${url.origin}${url.pathname}`;\n    };\n  };\n  /**\n   * Creates GET and POST routes to catch failed Measurement Protocol hits.\n   *\n   * @param {Plugin} queuePlugin\n   * @return {Array<Route>} The created routes.\n   *\n   * @private\n   */\n\n\n  const createCollectRoutes = queuePlugin => {\n    const match = ({\n      url\n    }) => url.hostname === GOOGLE_ANALYTICS_HOST && COLLECT_PATHS_REGEX.test(url.pathname);\n\n    const handler = new NetworkOnly_mjs.NetworkOnly({\n      plugins: [queuePlugin]\n    });\n    return [new Route_mjs.Route(match, handler, 'GET'), new Route_mjs.Route(match, handler, 'POST')];\n  };\n  /**\n   * Creates a route with a network first strategy for the analytics.js script.\n   *\n   * @param {string} cacheName\n   * @return {Route} The created route.\n   *\n   * @private\n   */\n\n\n  const createAnalyticsJsRoute = cacheName => {\n    const match = ({\n      url\n    }) => url.hostname === GOOGLE_ANALYTICS_HOST && url.pathname === ANALYTICS_JS_PATH;\n\n    const handler = new NetworkFirst_mjs.NetworkFirst({\n      cacheName\n    });\n    return new Route_mjs.Route(match, handler, 'GET');\n  };\n  /**\n   * Creates a route with a network first strategy for the gtag.js script.\n   *\n   * @param {string} cacheName\n   * @return {Route} The created route.\n   *\n   * @private\n   */\n\n\n  const createGtagJsRoute = cacheName => {\n    const match = ({\n      url\n    }) => url.hostname === GTM_HOST && url.pathname === GTAG_JS_PATH;\n\n    const handler = new NetworkFirst_mjs.NetworkFirst({\n      cacheName\n    });\n    return new Route_mjs.Route(match, handler, 'GET');\n  };\n  /**\n   * @param {Object=} [options]\n   * @param {Object} [options.cacheName] The cache name to store and retrieve\n   *     analytics.js. Defaults to the cache names provided by `workbox-core`.\n   * @param {Object} [options.parameterOverrides]\n   *     [Measurement Protocol parameters](https://developers.google.com/analytics/devguides/collection/protocol/v1/parameters),\n   *     expressed as key/value pairs, to be added to replayed Google Analytics\n   *     requests. This can be used to, e.g., set a custom dimension indicating\n   *     that the request was replayed.\n   * @param {Function} [options.hitFilter] A function that allows you to modify\n   *     the hit parameters prior to replaying\n   *     the hit. The function is invoked with the original hit's URLSearchParams\n   *     object as its only argument.\n   *\n   * @memberof workbox.googleAnalytics\n   */\n\n\n  const initialize = (options = {}) => {\n    const cacheName = cacheNames_mjs.cacheNames.getGoogleAnalyticsName(options.cacheName);\n    const queuePlugin = new Plugin_mjs.Plugin(QUEUE_NAME, {\n      maxRetentionTime: MAX_RETENTION_TIME,\n      callbacks: {\n        requestWillReplay: createRequestWillReplayCallback(options)\n      }\n    });\n    const routes = [createAnalyticsJsRoute(cacheName), createGtagJsRoute(cacheName), ...createCollectRoutes(queuePlugin)];\n    const router = new Router_mjs.Router();\n\n    for (const route of routes) {\n      router.registerRoute(route);\n    }\n\n    router.addFetchListener();\n  };\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  exports.initialize = initialize;\n\n  return exports;\n\n}({},workbox.backgroundSync,workbox.core._private,workbox.routing,workbox.routing,workbox.strategies,workbox.strategies));\n"],"file":"workbox-offline-ga.dev.js"}