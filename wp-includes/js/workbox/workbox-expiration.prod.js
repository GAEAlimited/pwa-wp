this.workbox=this.workbox||{},this.workbox.expiration=function(t,e,s,i,a,h){"use strict";try{self["workbox:expiration:4.0.0-rc.0"]&&_()}catch(t){}const n="workbox-expiration",c="cache-entries",r=t=>{const e=new URL(t,location);return e.hash="",e.href};class o{constructor(t){this.t=t,this.e=new e.DBWrapper(n,1,{onupgradeneeded:t=>this.s(t)})}s(t){const e=t.target.result.createObjectStore(c,{keyPath:"id"});e.createIndex("cacheName","cacheName",{unique:!1}),e.createIndex("timestamp","timestamp",{unique:!1}),s.deleteDatabase(this.t)}async setTimestamp(t,e){t=r(t),await this.e.put(c,{url:t,timestamp:e,cacheName:this.t,id:this.i(t)})}async getTimestamp(t){return(await this.e.get(c,this.i(t))).timestamp}async expireEntries(t,e){return await this.e.transaction(c,"readwrite",(s,i)=>{const a=s.objectStore(c),h=[];let n=0;a.index("timestamp").openCursor(null,"prev").onsuccess=(({target:s})=>{const a=s.result;if(a){const s=a.value;s.cacheName===this.t&&(t&&s.timestamp<t||e&&n>=e?(a.delete(),h.push(a.value.url)):n++),a.continue()}else i(h)})})}i(t){return this.t+"|"+r(t)}}class u{constructor(t,e={}){this.a=!1,this.h=!1,this.n=e.maxEntries,this.c=e.maxAgeSeconds,this.t=t,this.r=new o(t)}async expireEntries(){if(this.a)return void(this.h=!0);this.a=!0;const t=this.c?Date.now()-1e3*this.c:void 0,e=await this.r.expireEntries(t,this.n),s=await caches.open(this.t);for(const t of e)await s.delete(t);this.a=!1,this.h&&(this.h=!1,this.expireEntries())}async updateTimestamp(t){await this.r.setTimestamp(t,Date.now())}async isURLExpired(t){return await this.r.getTimestamp(t)<Date.now()-1e3*this.c}async delete(){this.h=!1,await this.r.expireEntries(1/0)}}return t.CacheExpiration=u,t.Plugin=class{constructor(t={}){this.o=t,this.c=t.maxAgeSeconds,this.u=new Map,t.purgeOnQuotaError&&h.registerQuotaErrorCallback(()=>this.deleteCacheAndMetadata())}w(t){if(t===a.cacheNames.getRuntimeName())throw new i.WorkboxError("expire-custom-caches-only");let e=this.u.get(t);return e||(e=new u(t,this.o),this.u.set(t,e)),e}cachedResponseWillBeUsed({event:t,request:e,cacheName:s,cachedResponse:i}){if(!i)return null;let a=this.l(i);const h=this.w(s);h.expireEntries();const n=h.updateTimestamp(e.url);if(t)try{t.waitUntil(n)}catch(t){}return a?i:null}l(t){if(!this.c)return!0;const e=this.d(t);return null===e||e>=Date.now()-1e3*this.c}d(t){if(!t.headers.has("date"))return null;const e=t.headers.get("date"),s=new Date(e).getTime();return isNaN(s)?null:s}async cacheDidUpdate({cacheName:t,request:e}){const s=this.w(t);await s.updateTimestamp(e.url),await s.expireEntries()}async deleteCacheAndMetadata(){for(const[t,e]of this.u)await caches.delete(t),await e.delete();this.u=new Map}},t}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core);

//# sourceMappingURL=workbox-expiration.prod.js.map
