this.workbox=this.workbox||{},this.workbox.backgroundSync=function(t,e){"use strict";try{self.workbox.v["workbox:background-sync:4.0.0-alpha.0"]=1}catch(t){}const s=["method","referrer","referrerPolicy","mode","credentials","cache","redirect","integrity","keepalive"];class i{static async fromRequest(t){const e={headers:{}};"GET"!==t.method&&(e.body=await t.clone().blob());for(const[s,i]of t.headers.entries())e.headers[s]=i;for(const i of s)void 0!==t[i]&&(e[i]=t[i]);return new i({url:t.url,requestInit:e})}constructor({url:t,requestInit:e,timestamp:s=Date.now()}){this.url=t,this.requestInit=e,this.t=s}get timestamp(){return this.t}toObject(){return{url:this.url,timestamp:this.timestamp,requestInit:this.requestInit}}toRequest(){return new Request(this.url,this.requestInit)}clone(){const t=Object.assign({},this.requestInit);return t.headers=Object.assign({},this.requestInit.headers),this.requestInit.body&&(t.body=this.requestInit.body.slice()),new i({url:this.url,timestamp:this.timestamp,requestInit:t})}}const n="workbox-background-sync",a="requests",r="queueName",c="workbox-background-sync",u=10080;class h{constructor(e){this.e=e,this.s=new t.DBWrapper(n,1,{onupgradeneeded:t=>t.target.result.createObjectStore(a,{autoIncrement:!0}).createIndex(r,r,{unique:!1})})}async addEntry(t){await this.s.add(a,{queueName:this.e.name,storableRequest:t.toObject()})}async getAndRemoveOldestEntry(){const[t]=await this.s.getAllMatching(a,{index:r,query:IDBKeyRange.only(this.e.name),count:1,includeKeys:!0});if(t)return await this.s.delete(a,t.primaryKey),new i(t.value.storableRequest)}}const o=new Set;class l{constructor(t,{callbacks:s={},maxRetentionTime:i=u}={}){if(o.has(t))throw new e.WorkboxError("duplicate-queue-name",{name:t});o.add(t),this.i=t,this.n=s,this.a=i,this.r=new h(this),this.c()}get name(){return this.i}async addRequest(t){const e=await i.fromRequest(t.clone());await this.u("requestWillEnqueue",e),await this.r.addEntry(e),await this.h()}async replayRequests(){const t=Date.now(),s=[],i=[];let n;for(;n=await this.r.getAndRemoveOldestEntry();){const e=n.clone(),a=60*this.a*1e3;if(t-n.timestamp>a)continue;await this.u("requestWillReplay",n);const r={request:n.toRequest()};try{r.response=await fetch(r.request.clone())}catch(t){r.error=t,i.push(e)}s.push(r)}if(await this.u("queueDidReplay",s),i.length)throw await Promise.all(i.map(t=>this.r.addEntry(t))),new e.WorkboxError("queue-replay-failed",{name:this.i,count:i.length})}async u(t,...e){"function"==typeof this.n[t]&&await this.n[t].apply(null,e)}c(){"sync"in registration?self.addEventListener("sync",t=>{t.tag===`${c}:${this.i}`&&t.waitUntil(this.replayRequests())}):this.replayRequests()}async h(){if("sync"in registration)try{await registration.sync.register(`${c}:${this.i}`)}catch(t){}}static get o(){return o}}return Object.freeze({Queue:l,Plugin:class{constructor(...t){this.e=new l(...t),this.fetchDidFail=this.fetchDidFail.bind(this)}async fetchDidFail({request:t}){await this.e.addRequest(t)}}})}(workbox.core._private,workbox.core._private);

//# sourceMappingURL=workbox-background-sync.prod.js.map
